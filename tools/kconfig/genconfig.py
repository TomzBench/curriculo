#!/usr/bin/env python3
"""Generate C header and CMake file from Kconfig configuration.

Uses kconfiglib to parse Kconfig files and merge prj.conf fragments.
Outputs:
  - C header with #define CONFIG_* macros
  - CMake file with set(CONFIG_* ...) commands
"""

import argparse
import os
import sys
from pathlib import Path

try:
    import kconfiglib
except ImportError:
    print("ERROR: kconfiglib not found. Install with: uv pip install kconfiglib")
    sys.exit(1)


def generate_header(kconf: kconfiglib.Kconfig, output: Path) -> None:
    """Generate C header file from Kconfig."""
    lines = [
        "/* Auto-generated by genconfig.py - DO NOT EDIT */",
        "#ifndef QWIET_KCONFIG_H",
        "#define QWIET_KCONFIG_H",
        "",
    ]

    for sym in kconf.unique_defined_syms:
        name = sym.name
        if sym.type == kconfiglib.BOOL:
            if sym.tri_value == 2:  # y
                lines.append(f"#define CONFIG_{name} 1")
        elif sym.type == kconfiglib.TRISTATE:
            if sym.tri_value == 2:  # y
                lines.append(f"#define CONFIG_{name} 1")
            elif sym.tri_value == 1:  # m
                lines.append(f"#define CONFIG_{name}_MODULE 1")
        elif sym.type == kconfiglib.STRING:
            lines.append(f'#define CONFIG_{name} "{sym.str_value}"')
        elif sym.type in (kconfiglib.INT, kconfiglib.HEX):
            lines.append(f"#define CONFIG_{name} {sym.str_value}")

    lines.extend(["", "#endif /* QWIET_KCONFIG_H */", ""])
    output.write_text("\n".join(lines))


def generate_cmake(kconf: kconfiglib.Kconfig, output: Path) -> None:
    """Generate CMake file with configuration variables."""
    lines = ["# Auto-generated by genconfig.py - DO NOT EDIT", ""]

    for sym in kconf.unique_defined_syms:
        name = sym.name
        if sym.type == kconfiglib.BOOL:
            value = "ON" if sym.tri_value == 2 else "OFF"
            lines.append(f"set(CONFIG_{name} {value})")
        elif sym.type == kconfiglib.TRISTATE:
            if sym.tri_value == 2:
                value = "y"
            elif sym.tri_value == 1:
                value = "m"
            else:
                value = "n"
            lines.append(f'set(CONFIG_{name} "{value}")')
        elif sym.type == kconfiglib.STRING:
            lines.append(f'set(CONFIG_{name} "{sym.str_value}")')
        elif sym.type in (kconfiglib.INT, kconfiglib.HEX):
            lines.append(f"set(CONFIG_{name} {sym.str_value})")

    lines.append("")
    output.write_text("\n".join(lines))


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate config from Kconfig")
    parser.add_argument("--kconfig-root", required=True, help="Root Kconfig file")
    parser.add_argument("--config", action="append", default=[], help="Config fragment(s)")
    parser.add_argument("--header", required=True, help="Output C header")
    parser.add_argument("--cmake", required=True, help="Output CMake file")
    args = parser.parse_args()

    # Set environment for kconfiglib (lowercase "srctree" is required by kconfiglib)
    os.environ["srctree"] = str(Path(args.kconfig_root).parent)  # noqa: SIM112

    # Parse Kconfig
    kconf = kconfiglib.Kconfig(args.kconfig_root)

    # Load config fragments (in order - later overrides earlier)
    for conf in args.config:
        if Path(conf).exists():
            kconf.load_config(conf, replace=False)

    # Generate outputs
    generate_header(kconf, Path(args.header))
    generate_cmake(kconf, Path(args.cmake))

    return 0


if __name__ == "__main__":
    sys.exit(main())
